<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>MazeSolver_CAL</title>
    <!-- Latest compiled and minified CSS -->
    <link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/slate/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-RpX8okQqCyUNG7PlOYNybyJXYTtGQH+7rIKiVvg1DLg6jahLEk47VvpUyS+E2/uJ" crossorigin="anonymous">

    <style>
        .grid {
            margin: 1em auto;
            border-collapse: collapse
        }

        .grid td {
            cursor: pointer;
            width: 40px;
            height: 40px;
            border: 1px solid #ccc;
            text-align: center;
            font-family: sans-serif;
            font-size: 13px
        }

        .grid td.blocked {
            background-color: black;
            font-weight: bold;
            color: white;
        }

        .grid td.start {
            background-color: green;
            font-weight: bold;
            color: black;
        }

        .grid td.end {
            background-color: red;
            font-weight: bold;
            color: black;
        }

        .grid td.greyed {
            background-color: grey;
            font-weight: bold;
            color: black;
        }

        .grid td.lime {
            background-color: lightgoldenrodyellow;
            font-weight: bold;
            color: black;
            transition-delay: 0.75s;
        }

        .grid td.path {
            background-color: royalblue;
            font-weight: bold;
            color: black;
            transition-delay: 0.25s;
        }

        .grid td.debug {
            background-color: black;
            font-weight: bold;
            color: yellow;
        }
    </style>
</head>
<body>
<div align="center">
    <table class="table table-striped table-hover ">
        <tr>
            <td width="120px">
                <div class="btn-group-vertical">
                    <input id="setStart" type="button" value="Select Start" onclick="setStartBtn();"
                           class="btn btn-success"/>
                    <br>
                    <input id="setEnd" type="button" value="Select End" onclick="setEndBtn();" class="btn btn-danger"/>
                </div>
            </td>
            <td width="120px">
                <div class="btn-group-vertical">
                    <input id="setBlocks" type="button" value="Select Blocks" onclick="setBlocksBtn();"
                           class="btn btn-default"/>
                    <br>
                    <input id="setDebug" type="button" value="Debug Info" onclick="setDebugBtn();"
                           class="btn btn-info"/>
                </div>
            </td>
            <td width="180px">
                <input id="executeScript" type="button" value="Execute Algorithm" onclick="executeScriptBtn();"
                       class="btn btn-warning"/>
                <br>
                <label for="perf">Perf Time[ms]: </label> <label id="perf"></label>

                <br>
                <label for="steps">Steps: </label> <label id="steps"></label>
                <br>
                <label for="blockcount">Blocks: </label> <label id="blockcount"></label>
            </td>
            <td>
                <div class="radio">
                    <input type="radio" id="pythag" name="method" value="pythag" checked="checked"
                           onclick="executeScriptBtn();"/>
                    <label for="pythag">A* Pythagorean Weight</label><br>
                    <input type="radio" id="manhattan" name="method" value="manhattan" onclick="executeScriptBtn();"/>
                    <label for="manhattan">A* Manhattan Weight</label><br>
                    <input type="radio" id="Dijkstra" name="method" value="Dijkstra" onclick="executeScriptBtn();"/>
                    <label for="Dijkstra">Dijkstra's Algorithm</label>
                </div>
                <div class="checkbox">
                    <input type="checkbox" id="Dijkstra_shortcut" name="Dijkstra_shortcut"
                           value="Dijkstra_shortcut" checked="checked" onclick="executeScriptBtn();"/>
                    <label for="Dijkstra_shortcut">Dijkstra "Shortcut"</label></div>
            </td>
        </tr>
    </table>
</div>
<br>
<div id="debug" style="display: none">
    <table class="table table-striped table-hover ">
        <tr>
            <td width="240px">
                <br>
                <label>Grid Parameters</label>
                <div class="form-group">
                    <div class="col-lg-10">
                        <input type="text" class="form-control" id="row_len" placeholder="Rows" value="">
                    </div>
                </div>

                <div class="form-group">
                    <div class="col-lg-10">
                        <input type="text" class="form-control" id="col_len" placeholder="Columns" value="">
                    </div>
                </div>

                <div>
                    <input id="rebuildgrid" type="button" value="Rebuild Grid" onclick="rebuildGrid();"
                           class="btn btn-default"/>
                    <!--<input id="reset" type="button" value="Reset Blocks" onclick="resetBtn();" class="btn btn-default"/>-->
                </div>
                <br>
                <label for="start">Start Position: </label> <label id="start"></label>
                <br>
                <label for="end">End Position: </label> <label id="end"></label>
                <!--<h5><input id="foo" type="button" value="foo" onclick="fooBtn();" hidden="true"/></h5>-->
                <!--<h5><input id="bar" type="button" value="bar" onclick="barBtn();" hidden="true"/></h5>-->

            </td>
            <td>
                <div class="col-lg-10">
                    <label for="steps_lookback">Steps: </label>
                    <textarea class="form-control" rows="2" id="steps_lookback" readonly></textarea>
                </div>
                <!--<label id="steps_lookback"></label>-->

                <div class="col-lg-10">
                    <label for="blocked">Blocked: </label>
                    <textarea class="form-control" rows="2" id="blocked" readonly></textarea>
                </div>


                <div class="col-lg-10">
                    <label for="msg">Log:</label>
                    <textarea class="form-control" rows="5" id="msg" readonly></textarea>
                </div>

            </td>
            <td>

                <br>

                <div class="checkbox">
                    <input type="checkbox" id="show_sampled_nodes" name="show_sampled_nodes" value="show_sampled_nodes"
                           checked="checked" onclick="Util.cleanup();"/>
                    <label for="show_sampled_nodes">Show Sampled Nodes</label></div>

                <div class="checkbox">
                    <input type="checkbox" id="end_rerun" name="end_rerun" value="end_rerun" checked="checked"/>
                    <label for="end_rerun">AutoRun On End Select</label></div>

                <div class="checkbox">
                    <input type="checkbox" id="start_rerun" name="start_rerun" value="start_rerun" checked="checked"/>
                    <label for="start_rerun">AutoRun On Start Select</label></div>

                <div class="checkbox">
                    <input type="checkbox" id="block_rerun" name="block_rerun" value="block_rerun" checked="checked"/>
                    <label for="block_rerun">AutoRun On Block Select</label></div>

            </td>
        </tr>
    </table>
</div>

<script type="text/javascript">
    /*
     *
     * try "namespacing" variables and functions inside other named Objects. This is mostly for neatness
     * investigate a minheap for popping the node with lowest value
     * constant names should be all caps. "class" names should be capitalized
     * */
    var rowLen = 16;
    var colLen = 16;
    var editorMode = 'setBlocks';
    var startNode;
    var endNode;
    var y_dict = [];
    var x_dict = [];
    var gridMap = [];
    var blocked = [];
    var method;

    function barBtn() {
        Util.log("You clicked on barBtn");
        //testing the get min out of dict function..
        //popMinNodeTest();
    }
    function fooBtn() {
        Util.log("You clicked on fooBtn");
        //test A* weight compute
        //ComputeWeightTest();
    }
    function setDebugBtn() {
        Util.log("You clicked on setDebugBtn");
        //editorMode = 'setDebug';
        var x = document.getElementById('debug');
        if (x.style.display === 'none') {
            /*
             document.getElementById('perf').innerHTML = perf.toString();
             document.getElementById('start').innerHTML = startNode.toString();
             document.getElementById('end').innerHTML = endNode.toString();
             document.getElementById('steps').innerHTML = Object.keys(steps).length.toString();
             document.getElementById('steps_lookback').innerHTML = steps_lookback.toString();
             */
            x.style.display = 'block';
        } else {
            x.style.display = 'none';
        }
    }
    function setBlocksBtn() {
        Util.log("You clicked on setBlocksBtn");
        editorMode = 'setBlocks'
    }
    function setStartBtn() {
        Util.log("You clicked on setStartBtn");
        editorMode = 'setStart'
    }
    function setEndBtn() {
        Util.log("You clicked on setEndBtn");
        editorMode = 'setEnd'
    }
    function executeScriptBtn() {
        Util.log("You clicked on executeScriptBtn");
        if (!startNode && !endNode) {
            gridMap[rowLen * colLen].className = 'end';
            endNode = rowLen * colLen;
            gridMap[1].className = 'start';
            startNode = 1;
            document.getElementById('start').innerHTML = startNode.toString();
            document.getElementById('end').innerHTML = endNode.toString();
        }
        Util.cleanup();
        if (!startNode) {
            alert("please select start node");
            return -1;
        }
        if (!endNode) {
            alert("please select end node");
            return -1;
        }
        var t0;
        var t1;
        var perf;
        var d = document.getElementById('Dijkstra').checked;
        if (d) {
            t0 = performance.now();
            Dijkstra();
            t1 = performance.now();
            perf = t1 - t0;
            document.getElementById('perf').innerHTML = perf.toString();
            return;
        }
        var k = document.getElementById('manhattan').checked;
        if (k) {
            method = "manhattan";
        }
        else {
            method = "pythag";
        }
        t0 = performance.now();
        AStar.runAstar();
        t1 = performance.now();
        perf = t1 - t0;
        document.getElementById('perf').innerHTML = perf.toString();
    }
    /**
     * @return {number}
     */
    var Util = {};
    Util.findNorth = function (i) {
        if (i <= rowLen) {
            return -1;
        }
        else {
            return parseInt(i) - parseInt(rowLen);
        }
    };
    Util.findSouth = function (i) {
        if (i > rowLen * (colLen - 1)) {
            return -1;
        }
        else {
            return parseInt(i) + parseInt(rowLen);
        }
    };
    Util.findEast = function (i) {
        if (i % (rowLen) == 0) {
            return -1;
        }
        else {
            return parseInt(i) + 1;
        }
    };
    Util.findWest = function (i) {
        if (i % (rowLen) == 1) {
            return -1;
        }
        else {
            return parseInt(i) - 1;
        }
    };
    Util.cleanup = function () {

        for (var k in gridMap) {
            if (k != startNode && k != endNode) {
                gridMap[k].className = '';
            }
        }
        for (var t in blocked) {
            gridMap[blocked[t]].className = 'blocked';
        }
        gridMap[startNode].className = 'start';
        gridMap[endNode].className = 'end';
    };
    Util.colorPath = function (prevNode, steps) {
        Util.log('ColorPath ' + steps.toString());
        var steps_lookback = [];
        var lookback = endNode;
        while (lookback != startNode) {
            var ts = prevNode[lookback];
            steps_lookback.push(ts);
            lookback = ts;
        }
        for (var slb in steps_lookback) {
            if (steps_lookback[slb] != startNode)
                gridMap[steps_lookback[slb]].className = 'path';
        }
        var stepString = Object.keys(steps).length.toString();
        var blockString = Object.keys(blocked).length.toString();
        var totalString = (rowLen * colLen).toString();
        document.getElementById('blockcount').innerHTML = blockString + "/" + totalString;
        document.getElementById('steps').innerHTML = stepString + "/" + totalString;
        document.getElementById('steps_lookback').innerHTML = steps_lookback.toString();
    };
    Util.log = function (i) {
        document.getElementById('msg').innerHTML = i.toString() + '\n' + document.getElementById('msg').innerHTML;
        console.log(i);
    };
    function Dijkstra() {
        var alreadyChecked = [];
        var todoNodes = [];
        var shortestCost = [];
        var prevNode = [];
        delete x_dict[0];
        for (var t in x_dict) {
            shortestCost[t] = Number.MAX_VALUE;
            prevNode[t] = 0;
            todoNodes[t] = 0;
        }
        var currentNode = startNode;
        var steps = [];
        shortestCost[startNode] = 0;
        //we record the distance to each node directly reachable in that node's table.
        // We should also record that the start node was the previous one.
        // Start node done! Mark it checked.
        //iterate until we are have nothing else.

        function PopMinNodeTodo() {
            //this should probably be implemented with a heap so operations can be log n time..
            var low_key = -1;
            var low_value = Number.MAX_VALUE;
            for (var key in shortestCost) {
                if (shortestCost[key] < low_value) {
                    if (todoNodes[key] == 0) {
                        low_key = key;
                        low_value = shortestCost[key];
                    }
                }
            }
            delete todoNodes[low_key];
            return parseInt(low_key);
        }

        function processNeighbor(n) {
            var k = (1 + shortestCost[currentNode]);
            if (k < shortestCost[n]) {
                shortestCost[n] = k;
                prevNode[n] = currentNode;
            }
        }

        var shortcut = document.getElementById('Dijkstra_shortcut').checked;
        delete todoNodes[0];
        function isBlocked(i, alreadyChecked) {
            // if its been blocked or we have already seen it, true..
            if (i == -1) return true;
            return blocked.indexOf(i) > -1 || alreadyChecked.indexOf(i) > -1;
        }

        while (todoNodes) {

            //we pick the node with the shortest distance that hasn't yet been checked.
            currentNode = PopMinNodeTodo();

            //we've exhausted everything
            if (currentNode == -1) {
                Util.log("Dijkstra done, currentNode == -1 ");
                for (var node in prevNode)
                    if (node == endNode) {
                        Util.colorPath(prevNode, steps);
                        Util.log("Dijkstra found solution !");
                        return;
                    }
                Util.log("Dijkstra failed to find solution !");
                return;
            }
            //Jump to that node and follow all edges that lead from it
            steps.push(parseInt(currentNode));
            var n = Util.findNorth(currentNode);
            var s = Util.findSouth(currentNode);
            var e = Util.findEast(currentNode);
            var w = Util.findWest(currentNode);
            if (!isBlocked(n, alreadyChecked)) {
                processNeighbor(n);
            }
            if (!isBlocked(s, alreadyChecked)) {
                processNeighbor(s);
            }
            if (!isBlocked(e, alreadyChecked)) {
                processNeighbor(e);
            }
            if (!isBlocked(w, alreadyChecked)) {
                processNeighbor(w);
            }
            //mark the node

            if (document.getElementById('show_sampled_nodes').checked)
                if (currentNode >= 0 && currentNode != startNode && currentNode != endNode) {
                    gridMap[currentNode].className = 'lime';
                }
            alreadyChecked.push(currentNode);
            // this is a Dijkstra shortcut
            if (shortcut == true) {
                if (currentNode == endNode) {
                    Util.log("Dijkstra shortcut - found solution");
                    Util.colorPath(prevNode, steps);
                    break;
                }
            }
        }
    }
    var AStar = {};
    AStar.AStarWeight = function (start, end) {
        var x_diff = Math.abs(x_dict[start] - x_dict[end]);
        var y_diff = Math.abs(y_dict[start] - y_dict[end]);
        var dist;
        if (method == "pythag")
            dist = Math.sqrt(Math.pow(x_diff, 2) + Math.pow(y_diff, 2));
        else //if (method == "manhattan")
            dist = (y_diff + x_diff );
        //Util.log("generate weight ", x_diff, y_diff, dist);
        return dist;
    };
    /**
     * @return {number}
     */
    AStar.runAstar = function () {
        var currentNode = startNode;
        var steps = [];
        var todo_dict = new Array(colLen * rowLen);
        var parent_dict = new Array(colLen * rowLen);
        //var parent_dict =[];
        //push start node
        todo_dict[startNode] = 0;
        /**
         * @return {number}
         */
        function PopMinNode() {
            if (!todo_dict)
                return -1;
            var low_key = null;
            var low_value = Number.MAX_VALUE;
            for (var key in todo_dict) {
                if (todo_dict[key] < low_value) {
                    low_key = key;
                    low_value = todo_dict[key];
                }
            }
            delete todo_dict[low_key];
            return parseInt(low_key);
        }

        function isBlocked(i) {
            // if its been blocked or we have already seen it, true..
            if (i == -1) return true;
            return blocked.indexOf(i) > -1 || steps.indexOf(i) > -1;
        }

        while (todo_dict) {
            // look up pop ??
            currentNode = PopMinNode();
            //Util.log("popped ", currentNode);
            steps.push(currentNode);

            if (document.getElementById('show_sampled_nodes').checked)
                if (currentNode >= 0 && currentNode != startNode && currentNode != endNode) {
                    gridMap[currentNode].className = 'lime';
                }

            //finished !
            if (currentNode == endNode) {
                Util.log("done - currentNode == endNode ");
                Util.colorPath(parent_dict, steps);
                break;
            }
            var n = Util.findNorth(currentNode);
            var s = Util.findSouth(currentNode);
            var e = Util.findEast(currentNode);
            var w = Util.findWest(currentNode);
            // heursitic for generating distances
            if (!isBlocked(n) && !todo_dict[n]) {
                todo_dict[n] = AStar.AStarWeight(n, endNode);
                parent_dict[n] = currentNode;
            }
            if (!isBlocked(s) && !todo_dict[s]) {
                todo_dict[s] = AStar.AStarWeight(s, endNode);
                parent_dict[s] = currentNode;
            }
            if (!isBlocked(w) && !todo_dict[w]) {
                todo_dict[w] = AStar.AStarWeight(w, endNode);
                parent_dict[w] = currentNode;
            }
            if (!isBlocked(e) && !todo_dict[e]) {
                todo_dict[e] = AStar.AStarWeight(e, endNode);
                parent_dict[e] = currentNode;
            }
        }
    };
    buildGrid(colLen, rowLen);

    function rebuildGrid() {
        Util.log('Rebuilding Grid');
        startNode = null;
        endNode = null;

        blocked = [];
        document.getElementById('steps').innerHTML = '';
        document.getElementById('steps_lookback').innerHTML = '';
        document.getElementById('blocked').innerHTML = '';
        document.getElementById('start').innerHTML = '';
        document.getElementById('end').innerHTML = '';

        if (document.getElementById('col_len').value)
            colLen = parseInt(document.getElementById('col_len').value);

        if (document.getElementById('row_len').value)
            rowLen = parseInt(document.getElementById('row_len').value);

        Util.log('Clearing maze grid');
        document.getElementById('mazeGrid').outerHTML = '';
        if (!colLen || colLen < 1) {
            alert("please enter a valid column length");
            return;
        }
        if (!rowLen || rowLen < 1) {
            alert("please enter a valid row length");
            return;
        }

        buildGrid(colLen, rowLen);
        Util.cleanup();
    }

    function buildGrid(colLen, rowLen) {
        Util.log('Building Grid');
        var clickNode = function (el, row, col, i) {
            /*
             util.log("You clicked on element:", el);
             util.log("You clicked on row:", row);
             util.log("You clicked on col:", col);*/
            Util.log("You clicked on node #:" + i);
            Util.cleanup();

            if (i == startNode)
                return;
            if (i == endNode)
                return;

            switch (editorMode) {
                case
                'setBlocks':
                    var index = blocked.indexOf(i);
                    if (index > -1) // found this i in the blocked list
                    {
                        Util.log('Removing from blocked ' + i);
                        el.className = '';
                        blocked.splice(index, 1);
                    }
                    else    // did not util.find i in blocked list
                    {
                        el.className = 'blocked';
                        blocked.push(i)
                    }

                    //do we want to re-run on this condition?
                    document.getElementById('blocked').innerHTML = blocked.toString();
                    if (document.getElementById('block_rerun').checked)
                        executeScriptBtn();
                    break;
                case 'setStart':

                    if (blocked.indexOf(i) > -1) {
                        return;
                    }// found this i in the blocked list

                    if (startNode) gridMap[startNode].className = '';
                    el.className = 'start';
                    startNode = i;

                    Util.log('StartNode set to ' + i);
                    //do we want to re-run on this condition?
                    document.getElementById('start').innerHTML = startNode.toString();
                    if (document.getElementById('start_rerun').checked)
                        executeScriptBtn();
                    break;
                case 'setEnd':
                    if (blocked.indexOf(i) > -1) {
                        return;
                    }// found this i in the blocked list

                    if (endNode) gridMap[endNode].className = '';
                    el.className = 'end';
                    endNode = i;

                    Util.log('EndNode set to ' + i);
                    //do we want to re-run on this condition?
                    document.getElementById('end').innerHTML = endNode.toString();
                    if (document.getElementById('end_rerun').checked)
                        executeScriptBtn();
                    break;
            }
        };
        var grid = clickableGrid(colLen, rowLen, clickNode);
        document.body.appendChild(grid);
        grid.id = 'mazeGrid';
        return grid;
    }
    function clickableGrid(rows, cols, callback) {
        var i = 0;
        var grid = document.createElement('table');
        grid.className = 'grid';
        for (var r = 0; r < rows; ++r) {
            var tr = grid.appendChild(document.createElement('tr'));
            for (var c = 0; c < cols; ++c) {
                var cell = tr.appendChild(document.createElement('td'));
                cell.innerHTML = ++i;
                gridMap[i] = cell;
                y_dict[i] = c;
                x_dict[i] = r;
                cell.addEventListener('click', (function (el, r, c, i) {
                    return function () {
                        callback(el, r, c, i);
                    }
                })(cell, r, c, i), false);
            }
        }
        return grid;
    }
    executeScriptBtn();
</script>

</body>
</html>